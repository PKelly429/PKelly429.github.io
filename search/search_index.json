{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Paul Kelly Dev Logs","text":""},{"location":"RTS%20Prototype/Fog%20of%20War%20-%20Vision%20Calculations/","title":"Fog of War - Vision Calculations","text":"<p>To get our Fog of War working we need to keep track of what areas of the map the player is able to see. Once we know what grid cells are visible, we can write that data to a texture and use a shader to render the fog of war.</p>"},{"location":"RTS%20Prototype/Fog%20of%20War%20-%20Vision%20Calculations/#resources","title":"Resources:","text":"<p>implementing fog of war for rts game in unity</p> <p>riot games fog of war story</p> <p>visibility</p>"},{"location":"RTS%20Prototype/Fog%20of%20War%20-%20Vision%20Calculations/#basic-solution","title":"Basic Solution","text":"<p>To do this we can keep count of how many units are able to see each cell.</p> <p>The most simple solution is to iterate over every unit, remove them from each cell they can see, update their position and re-add them with the new position.</p> <p>To find which cells a unit can see we can loop over a grid from -radius to +radius, centred around the unit. Then test if each cell overlaps with the vision circle.</p> <p>'unitsWithVisionInCell' is a flattened 2d array where [x,y] = [y*width + x]</p> <pre><code>public void Update()\n{\n    foreach(unit in allUnits)\n    {\n        UpdateUnitVisibility(unit.gridPos, unit.radius, false);\n        unit.gridPos = WorldToGridPos(unit.position);\n        UpdateUnitVisibility(unit.gridPos, unit.radius, true);\n    }\n\n    UpdateTexture();\n}\n\nprivate void UpdateUnitVisibility(GridCell pos, int radius, bool add)\n{\n    for(int x = pos.x-radius, x &lt; pos.x+radius; x++)\n    {\n        for(int y = pos.y-radius, y &lt; pos.y+radius; y++)\n        {\n            GridCell cell = new GridCell(x, y);\n            if(!cell.Overlaps(pos, radius)) continue;\n\n            if(add)\n            {\n                unitsWithVisionInCell[y * GridBounds + x]++;\n            }\n            else\n            {\n                unitsWithVisionInCell[y * GridBounds + x]--;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"RTS%20Prototype/Fog%20of%20War%20-%20Vision%20Calculations/#optimisations","title":"Optimisations","text":""},{"location":"RTS%20Prototype/Fog%20of%20War%20-%20Vision%20Calculations/#only-update-units-that-move","title":"Only Update Units that Move","text":"<p>Easy enough, if a unit doesn't move skip recalculating it's visibility </p> <pre><code>public void Update()\n{\n    foreach(unit in allUnits)\n    {\n        GridPos newPos = WorldToGridPos(unit.position);\n        if(unit.gridPos.Equals(newPos)) continue;\n\n        UpdateUnitVisibility(unit.gridPos, unit.radius, false);\n        unit.gridPos = newPos;\n        UpdateUnitVisibility(unit.gridPos, unit.radius, true);\n    }\n\n    UpdateTexture();\n}\n</code></pre>"},{"location":"RTS%20Prototype/Fog%20of%20War%20-%20Vision%20Calculations/#make-the-grid-smaller","title":"Make the Grid Smaller","text":"<p>For a unit with a range of 20 units, if the Grid Size is 1x1 then to calculate it's vision requires 20x20 = 400 comparisons. If we change the Grid Size to 2x2, then we only need 10x10 = 100 comparisons.</p> <p>So we perform 4x better if we reduce the Grid Size by 2x.</p> <p>This is obviously a balance between gameplay and performance as having too big a grid size will make the fog of war blocky, and potentially affect other systems e.g. if the Building System uses the same grid.</p>"},{"location":"RTS%20Prototype/Fog%20of%20War%20-%20Vision%20Calculations/#optimising-the-calculation","title":"Optimising the Calculation","text":"<p>Rather than iterate over a radius x radius grid and calculate if each cell overlaps, we can do better. Instead we calculate the height of each column, and only iterate over cells that are inside the circle.</p> <p>Bresenham's Algorithm</p> <p>Wikipedia</p> <pre><code>private void UpdateUnitVisibility(GridCell pos, int radius, bool increment)  \n{  \n    int radiusSquared = radius * radius;\n    for (int x = pos.x - radius; x &lt; pos.x + radius; x++)  \n    {  \n        int xOffset = x - pos.x;  \n        int height = (int)Math.Sqrt(radiusSquared - (xOffset * xOffset));  \n\n        for (int y = pos.y - height; y &lt; pos.y + height; y++)  \n        {\n\n            if (increment)  \n            {\n                unitsWithVisionInCell[y * GridBounds + x]++;  \n            }            \n            else  \n            {  \n                unitsWithVisionInCell[y * GridBounds + x]--;     \n            }  \n        }\n    }\n}\n</code></pre>"},{"location":"RTS%20Prototype/Fog%20of%20War%20-%20Vision%20Calculations/#further-improvement-to-the-calculation","title":"Further Improvement to the Calculation","text":"<p>If we know a unit has moved 1 grid space to the right, we know that most of the cells they occupy will remain the same. If we can calculate only the cells that need to change, we can reduce the number of cells that need to be considered.</p> <p></p> <p>I have left this optimisation for now, as it makes the code quite a bit more complicated, and after moving things to the Job system, more optimisation wasn't required.</p>"},{"location":"RTS%20Prototype/Fog%20of%20War%20-%20Vision%20Calculations/#unity-job-system","title":"Unity Job System","text":"<p>Unity Job System</p> <p>Using the Job System will allow us to move our calculations off the main thread, essentially making it free so long as it finishes before we need to use the result.</p> <p>The job system works best when used with the burst compiler, which does not allow managed types.</p>"},{"location":"RTS%20Prototype/Fog%20of%20War%20-%20Vision%20Calculations/#the-job-class","title":"The Job class","text":"<p>To work with the burst compiler our data needs to be converted to a structs and NativeArrays. </p> <p>The job will take in an array of Units that need to recalculate their vision, with the current and previous grid cell positions. A count is given to determine how far into the list to iterate.</p> <p>The job outputs a flattened 2d array with the number of units in a given cell.</p> <p>If possible we would like our jobs to be run in parallel, using IJobParallel rather than IJob. In this case, because each execution of the job wants to write to the output array in an undetermined order (i.e. units[0] does not exclusively write to unitsWithVisionInCell[0]), we cannot ensure thread safety and have to use a single job.</p> <pre><code>public struct UnitVision  \n{  \n    public GridCell lastGridCell;  \n    public GridCell newGridCell;  \n    public int radius;  \n}\n</code></pre> <p>The method 'UpdateUnitVisibility' is the same as before.</p> <pre><code>public struct UpdateUnitVisibilityJob : IJob  \n{  \n    [ReadOnly] public NativeArray&lt;UnitVision&gt; units;  \n    public NativeArray&lt;uint&gt; unitsWithVisionInCell;  \n\n    public int UnitCount;  \n    public int GridBounds;\n\n    public void Execute()  \n    {\n        for (int i = 0; i &lt; UnitCount; i++)  \n        {  \n            UnitVision unit = units[i];\n            int radiusSquared = radius * radius;\n            UpdateUnitVisibility(unit.lastGridCell radius, radiusSquared, false);  \n            UpdateUnitVisibility(unit.newGridCell, radius, radiusSquared, true);\n        }\n    }\n\n    private void UpdateUnitVisibility(GridCell pos, int radius, int radiusSquared bool increment)  \n    {\n        //...\n    }\n}\n</code></pre>"},{"location":"RTS%20Prototype/Fog%20of%20War%20-%20Vision%20Calculations/#the-schedular","title":"The Schedular","text":"<p>To run the job, we need to create an instance of it and run '.Schedule()'. This returns a job handle, and at some point we need to call .'Complete()' on the handle to ensure the job is finished.</p> <p>Our 'GridVisibilityManager' starts a job early in the frame, and then uses LateUpdate() to complete the job.</p> <p>The data being used by the job, in this case the 'unitsToProcess' and 'unitsWithVisionInCell' cannot be used while the job is running. Attempting to do so will cause the job to be finished on the main thread. This will need to be considered when using jobs. </p> <p>One strategy if the data needs to be freely available would be to create a copy that can be accessed at any time, and when the job finishes the data can be synced.</p> <p>In our case, we intend to use the data in another job, if this is the case we can use the previous job handle when scheduling the next job. This tells Unity that the next job depends on the previous one and the previous job must be completed first.</p> <pre><code>public class GridVisibilityManager : MonoBehaviour\n{\n    public const int WorldSize = 1024;  \n    public const int GridSize = 4;\n\n    public const int GridBounds = WorldSize / GridSize;\n\n    public const int MaxUnits = 100;\n\n    private NativeArray&lt;UnitVision&gt; unitsToProcess;  \n    private NativeArray&lt;uint&gt; unitsWithVisionInCell;\n\n    private readonly HashSet&lt;Unit&gt; allUnits = new HashSet&lt;Unit&gt;();\n\n    private JobHandle _updateLitCellsJobHandle;  \n    private bool _jobRunning;\n\n    public void RegisterUnit(Unit unit)  \n    {  \n        // when units are added, the job should skip the decrement step\n        // left out for brevity\n        allUnits.Add(unit);  \n    }  \n\n    public void DeregisterUnit(Unit unit)  \n    {  \n        // when units are removed, the job should skip the increment step\n        // left out for brevity\n        allUnits.Remove(unit);  \n    }\n\n    private void Start()  \n    {  \n        unitsToProcess = new NativeArray&lt;UnitVision&gt;(MaxUnits, Allocator.Persistent);  \n        unitsWithVisionInCell = new NativeArray&lt;uint&gt;(GridBounds * GridBounds, Allocator.Persistent);  \n    }\n\n    private void OnDestroy()  \n    {  \n        if (!_updateLitCellsJobHandle.IsCompleted)  \n        {        \n            _updateLitCellsJobHandle.Complete();  \n        }    \n\n        unitsToProcess.Dispose();  \n        unitsWithVisionInCell.Dispose();  \n    }\n\n\n    private void Update()  \n    {  \n        int processQueueIndex = 0;  \n        foreach (var unit in allUnits)  \n        {\n            // skip if unit hasn't moved  \n            GridCell newPos = GridCell.FromWorldPos(unit.Position);  \n            if(unit.GridPosition.Equals(newPos)) continue; \n\n            unitsToProcess[processQueueIndex] = new UnitVision()  \n            {  \n                newGridCell = newPos,  \n                lastGridCell = obj.GridPosition,  \n                radius = obj.Radius\n            };  \n\n            obj.GridPosition = newPos;  \n            processQueueIndex++;\n\n            if(processQueueIndex &gt;= MaxUnits) break;  \n        }  \n\n        if (processQueueIndex &gt; 0)  \n        {        \n            var job = new UpdateUnitVisibilityJob()  \n            {  \n                units = unitsToProcess,  \n                unitsWithVisionInCell = unitsWithVisionInCell,  \n                UnitCount = processQueueIndex,  \n                GridBounds = GridBounds  \n            };  \n\n            _updateLitCellsJobHandle = job.Schedule();  \n            _jobRunning = true;  \n        }\n    }  \n\n    private void LateUpdate()  \n    {  \n        if (!_jobRunning) return;\n\n        _updateLitCellsJobHandle.Complete();  \n        _jobRunning = false;  \n    }\n\n}\n</code></pre>"},{"location":"RTS%20Prototype/Fog%20of%20War%20-%20Vision%20Calculations/#the-burst-compiler","title":"The Burst Compiler","text":"<p>To use the burst compiler, we just need to add the attribute [BurstCompile].</p> <p>To test the speed of using the Burst compiler I turned off the optimisation to skip units that hadn't moved, and completed the job immediately to more easily profile how long it was taking.</p> <p>I added around 20-30 units to the scene, and the above was taking around 0.5ms.</p> <p>After adding the Burst compiler that went to 0.03ms, a 17x improvement.</p> <pre><code>[BurstCompile]  \npublic struct UpdateUnitVisibilityJob : IJob  \n{\n     //...\n}\n</code></pre> <p>Even without the further improvement of ignoring cells that a unit will remain in, the calculation is now having negligible impact on performance.</p>"},{"location":"RTS%20Prototype/Fog%20of%20War%20-%20Vision%20Calculations/#updating-the-texture","title":"Updating the Texture","text":"<p>To make use of the unit visibility info, we want to write the data into a texture, which can then be used by a shader. Writing to the texture can also be done in a job by creating a NativeArray using '.GetRawTextureData()'.</p> <p>On this same texture, we are using the red channel to determine which areas are buildable.</p> <pre><code>[BurstCompile]  \npublic struct UpdateGridTextureJob : IJobParallelFor  \n{  \n    [ReadOnly] public NativeArray&lt;bool&gt; blockedCells;  \n    [ReadOnly] public NativeArray&lt;uint&gt; unitsWithVisionInCell;  \n    [WriteOnly] public NativeArray&lt;Color32&gt; texture;  \n\n    public void Execute(int index)  \n    {        \n        byte r = blockedCells[index] ? byte.MaxValue : byte.MinValue;  \n        byte g = byte.MinValue;  \n        byte b = unitsWithVisionInCell[index] &gt; 0 ? byte.MaxValue : byte.MinValue; \n        byte a = byte.MaxValue;  \n\n        texture[index] = new Color32(r, g, b, a);  \n    }\n}\n</code></pre> <p>Because this job depends on the previous, we pass in the job handle '_updateLitCellsJobHandle' when scheduling.</p> <pre><code>[SerializeField] private Texture2D gridTexture;\nprivate NativeArray&lt;Color32&gt; gridTextureData;\n\nprivate void Start()\n{\n    // define the texture data\n    gridTextureData = gridTexture.GetRawTextureData&lt;Color32&gt;();\n}\n\n//...\n\nprivate void Update()\n{\n    // ...\n\n    // Schedule job after the calculations are finished\n    var updateTextureJob = new UpdateGridTextureJob()  \n    {  \n        blockedCells = blockedCells,  \n        unitsWithVisionInCell = unitsWithVisionInCell,  \n        texture = gridTextureData  \n    };  \n    _updateTextureJobHandle = updateTextureJob.Schedule(GridBounds*GridBounds, 8, _updateLitCellsJobHandle);\n}\n//...\n\nprivate void LateUpdate()\n{\n    // When job finished, apply the texture\n    _updateTextureJobHandle.Complete();\n    gridTexture.Apply();\n}\n</code></pre>"},{"location":"RTS%20Prototype/Handling%20Commands/","title":"Handling Commands","text":"<p>In most RTS games, clicking on a unit will display commands unique to that unit.</p> <p>I wanted to create a system that would allow me to define commands in a way that would be easily configurable.</p> <p></p>"},{"location":"RTS%20Prototype/Handling%20Commands/#the-idea","title":"The Idea","text":"<p>A Command scriptable object is used to manage the visuals for each Command, as well as hold an event that units can subscribe to if they are ready to respond to that event.</p> <p>This command object can then be bound to the UI.</p> <p>Another scriptable object, the Command Template is used to define what Commands a unit has and their order in the UI.</p> <p>A unit has a reference to a Command Template, along with scripts that subscribe to each Command and implement some code to execute when that Command is pressed.</p> <p></p>"},{"location":"RTS%20Prototype/Handling%20Commands/#how-adding-a-new-command-works","title":"How Adding a New Command Works","text":""},{"location":"RTS%20Prototype/Handling%20Commands/#create-a-new-command-object","title":"Create a new command object","text":"<p>Use the Create menu to create a new scriptable object and assign images for the button.</p> <p></p>"},{"location":"RTS%20Prototype/Handling%20Commands/#add-to-a-template","title":"Add to a Template","text":""},{"location":"RTS%20Prototype/Handling%20Commands/#write-code-for-units-to-implement-the-command","title":"Write Code for Units to Implement the Command","text":"<pre><code>public class DebugCommandListener : MonoBehaviour, ICommandRegister \n{  \n    [SerializeField] Command command;  \n\n    public void Register()  \n    {        \n        command.Register(RespondToDebugCommand);  \n    }  \n    public void Deregister()  \n    {        \n        command.Deregister(RespondToDebugCommand);  \n    }\n\n    public void RespondToDebugCommand()  \n    {        \n        Debug.Log(\"Unit has received debug command\");  \n    }\n}\n</code></pre> <p>Attach script to our unit and configure the command scriptable object. This could also be configured globally (e.g. In a static singleton with reference to all commands).</p> <p></p>"},{"location":"RTS%20Prototype/Handling%20Commands/#finished-adding-a-new-command","title":"Finished Adding a New Command","text":"<p>This command could now be assigned to multiple units, and easily moved to a new position.</p> <p></p>"},{"location":"RTS%20Prototype/Handling%20Commands/#implementation","title":"Implementation","text":""},{"location":"RTS%20Prototype/Handling%20Commands/#the-command-scriptable-object","title":"The Command Scriptable Object","text":"<p>First there is the <code>BaseCommand</code> script that defines the images and an Execute Method. The Execute Method will be called by the UI when the button is clicked (or a hotkey pressed).</p> <pre><code>[Serializable]  \npublic abstract class BaseCommand : ScriptableObject  \n{  \n    public Sprite image;  \n    public Sprite imageHover;  \n    public abstract void Execute();  \n}\n</code></pre> <p>Next there are two implementations, a regular command for simple actions (such as the Debug Command created here) and a generic command that can be used to create more complex commands requiring data. The Move command for example is a <code>Command&lt;Vector3&gt;</code>.</p> <p>These scripts contain an event that can be subscribed to. When a unit is selected it subscribes to all commands it has been configured for. This allows all selected units to respond to a command.</p> <p>The simple command immediately calls the event when pressed.</p> <pre><code>[CreateAssetMenu(menuName=\"Command/Command\")]  \npublic class Command : BaseCommand  \n{  \n    private event ExecuteCommand OnExecute = () =&gt; { };  \n\n    public delegate void ExecuteCommand();  \n\n    public override void Execute()  \n    {        \n        OnExecute.Invoke();  \n    }        \n    public void Register(ExecuteCommand action) =&gt; OnExecute += action;  \n    public void Deregister(ExecuteCommand action) =&gt; OnExecute -= action;  \n}  \n\npublic abstract class Command&lt;T&gt; : BaseCommand  \n{  \n    private event ExecuteCommand OnExecute = (value) =&gt; { };  \n\n    public delegate void ExecuteCommand(T value);  \n\n    // Does not implment Execute()\n    // Any implementation still needs to implement this method\n\n    public void ExecuteWithValue(T value)  \n    {        \n        OnExecute.Invoke(value);  \n    }        \n    public void Register(ExecuteCommand action) =&gt; OnExecute += action;  \n    public void Deregister(ExecuteCommand action) =&gt; OnExecute -= action;  \n}\n</code></pre>"},{"location":"RTS%20Prototype/Handling%20Commands/#position-commands","title":"Position Commands","text":"<p>The Move command is an instance of this Position Command, which requires a Vector3.</p> <pre><code>[CreateAssetMenu(menuName = \"Command/Position Command\")]  \npublic class Vector3Command : Command&lt;Vector3&gt;  \n{  \n    public override void Execute()  \n    {        \n        SceneReferences.Instance.inputHandler.SetCommand(this);  \n    }\n}\n</code></pre> <p>Rather than immediately invoke the <code>OnExecute</code> event, it first makes a call to the Input Handler. When the command is executed, the next click will order the unit to move to that position.</p> <pre><code>public void SetCommand(Vector3Command command)  \n{  \n    HasTargetCommand = true;  \n    currentTargetCommand = command;  \n}\n\n...\n\n// Called in Update if HasTargetCommand and mouse pressed this frame\nprivate void HandlePositionCommand(Ray ray) \n{      \n    int hits = Physics.RaycastNonAlloc(ray.origin, ray.direction, _hits, MaxDistance, groundLayers);  \n\n    if (hits &gt; 0)  \n    {\n        currentTargetCommand.ExecuteWithValue(_hits[0].point);  \n    }    \n\n    HasTargetCommand = false;  \n    currentTargetCommand = null;  \n}\n</code></pre>"},{"location":"RTS%20Prototype/Handling%20Commands/#command-templates","title":"Command Templates","text":"<p>This is attached to a script on each unit, and determines which commands should be shown when they are selected</p> <pre><code>[CreateAssetMenu(menuName = \"Command/Command Template\")]  \npublic class CommandTemplate : ScriptableObject \n{   \n    public BaseCommand[] commandRow1 = new BaseCommand[5];  \n    public BaseCommand[] commandRow2 = new BaseCommand[5];  \n    public BaseCommand[] commandRow3 = new BaseCommand[5];  \n}\n</code></pre>"},{"location":"RTS%20Prototype/Handling%20Commands/#the-units","title":"The Units","text":"<p>The units are configured with a number of scripts with the <code>ICommandRegister</code> interface. <code>MoveableEntity</code> implements the Move and Stop commands.</p> <pre><code>public interface ICommandRegister  \n{  \n    public void Register();  \n    public void Deregister();  \n}\n</code></pre> <p>The Selectable Object script gathers a reference to all scripts with this interface and when selected, they register to all commands.</p> <pre><code>[SerializeField] private CommandTemplate commands;\n\nprivate ICommandRegister[] commandListeners;  \n\nprivate void Start()  \n{  \n    commandListeners = GetComponents&lt;ICommandRegister&gt;();  \n}  \n\nprivate void RegisterCommands()  \n{  \n    SceneReferences.Instance.commandButtonGrid.Bind(commands);  \n    foreach (var commandListener in commandListeners)  \n    {        \n        commandListener.Register();  \n    }\n}  \n\nprivate void DeregisterCommands()  \n{  \n    foreach (var commandListener in commandListeners)  \n    {        \n        commandListener.Deregister();  \n    }\n}\n\npublic void OnSelect()  \n{  \n    ...\n\n    // This is a temporary measure to tell the UI to use this units commands\n    // When multiple units can be selected at once this will need a system to\n    // handle combining templates from all selected units\n    SceneReferences.Instance.commandButtonGrid.Bind(commands);\n\n    RegisterCommands();  \n}  \n\npublic void OnDeselect()  \n{  \n    ...\n    DeregisterCommands();  \n}\n</code></pre>"},{"location":"RTS%20Prototype/Handling%20Commands/#ui","title":"UI","text":"<p>Finally the UI has a list of button objects and iterates through each of them, binding them to the corresponding Command.</p> <pre><code>public void Bind(CommandTemplate unitCommands)  \n{  \n    if (unitCommands == null)  \n    {        \n        Unbind();  \n        return;  \n    }    \n    int next = 0;  \n    for (int i = 0; i &lt; unitCommands.commandRow1.Length; i++)  \n    {        \n        commandBinders[next].Bind(unitCommands.commandRow1[i]);  \n        next++;    \n    }    \n    for (int i = 0; i &lt; unitCommands.commandRow2.Length; i++)  \n    {        \n        commandBinders[next].Bind(unitCommands.commandRow2[i]);  \n        next++;    \n    }    \n    for (int i = 0; i &lt; unitCommands.commandRow3.Length; i++)  \n    {        \n        commandBinders[next].Bind(unitCommands.commandRow3[i]);  \n        next++;    \n    }\n}\n</code></pre> <pre><code>public class CommandBinder : MonoBehaviour  \n{  \n    [SerializeField] private Button button;  \n    [SerializeField] private Image icon;  \n    [SerializeField] private HighlightOnHover hover; //switches icon when hovered \n\n    public void Bind(BaseCommand command)  \n    {        \n        Unbind();  \n        if (command == null) return;\n\n        icon.enabled = true;  \n        icon.sprite = command.image;\n\n        button.enabled = true;  \n        button.onClick.AddListener(command.Execute); \n\n        hover.SetSprites(command.image, command.imageHover);  \n    }  \n\n    protected void Unbind()  \n    {        \n        icon.enabled = false;  \n        button.enabled = false;  \n        button.onClick.RemoveAllListeners();  \n    }\n}\n</code></pre>"},{"location":"RTS%20Prototype/Spatial%20Hashing/","title":"Spatial Hashing","text":""},{"location":"RTS%20Prototype/Spatial%20Hashing/#resources","title":"Resources","text":"<p>https://www.youtube.com/watch?v=S5NY1fqisSY https://www.youtube.com/watch?v=sx4IIQL0x7c https://www.youtube.com/watch?v=oewDaISQpw0</p>"},{"location":"Useful%20Scripts/Assign%20GUIDs%20Automatically/","title":"Assign GUIDs Automatically","text":"<p>Script for an attribute that automatically assigns a GUID to a string field on a Unity scriptable object. Works with duplicating objects using ctrl + d in the editor.</p>"},{"location":"Useful%20Scripts/Assign%20GUIDs%20Automatically/#usage","title":"Usage","text":"<pre><code>public class UniqueObject : ScriptableObject  \n{\n    [ScriptableObjectId] public string objectId;\n}\n</code></pre>"},{"location":"Useful%20Scripts/Assign%20GUIDs%20Automatically/#code","title":"Code","text":"<pre><code>using System;  \nusing UnityEngine;  \nusing Object = UnityEngine.Object;  \n#if UNITY_EDITOR  \nusing UnityEditor;  \n#endif  \n\n[AttributeUsage(AttributeTargets.Field)]  \npublic class ScriptableObjectIdAttribute : PropertyAttribute  \n{  \n}  \n\n#if UNITY_EDITOR  \n[CustomPropertyDrawer(typeof(ScriptableObjectIdAttribute))]  \npublic class ScriptableObjectIdDrawer : PropertyDrawer  \n{  \n    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)  \n    {        \n        GUI.enabled = false;  \n\n        Object owner = property.serializedObject.targetObject;  \n        // This is the unity managed GUID of the scriptable object, which is always unique  \n        string unityManagedGuid = AssetDatabase.AssetPathToGUID(AssetDatabase.GetAssetPath(owner));  \n\n        if (property.stringValue != unityManagedGuid)  \n        {            \n            property.stringValue = unityManagedGuid;  \n        }  \n        EditorGUI.PropertyField(position, property, label, true);  \n\n        GUI.enabled = true;  \n    }\n}  \n#endif\n</code></pre>"},{"location":"Useful%20Scripts/ReadOnly%20attribute/","title":"ReadOnly attribute","text":""},{"location":"Useful%20Scripts/ReadOnly%20attribute/#attribute","title":"Attribute","text":"<pre><code>public class ReadOnlyAttribute : PropertyAttribute  \n{  \n}\n</code></pre>"},{"location":"Useful%20Scripts/ReadOnly%20attribute/#property-drawer","title":"Property Drawer","text":"<p>(Put this inside an Editor folder)</p> <pre><code>using UnityEditor;  \nusing UnityEditor.UIElements;  \nusing UnityEngine;  \nusing UnityEngine.UIElements;  \n\n[CustomPropertyDrawer(typeof(ReadOnlyAttribute))]  \npublic class ReadOnlyDrawer : PropertyDrawer  \n{  \n    public override float GetPropertyHeight(SerializedProperty property,  \n        GUIContent label)  \n    {        \n        return EditorGUI.GetPropertyHeight(property, label, true);  \n    }  \n    public override VisualElement CreatePropertyGUI(SerializedProperty property)  \n    {        \n        VisualElement container = new VisualElement();  \n        PropertyField field = new PropertyField(property);  \n        field.SetEnabled(false);  \n        container.Add(field);  \n        return container;  \n    }  \n    public override void OnGUI(Rect position,  \n        SerializedProperty property,  \n        GUIContent label)  \n    {        \n        GUI.enabled = false;  \n        EditorGUI.PropertyField(position, property, label, true);  \n        GUI.enabled = true;  \n    }\n}\n</code></pre>"},{"location":"blog/","title":"Blog","text":""}]}